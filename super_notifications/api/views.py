# -*- coding: utf-8 -*-
from rest_framework import mixins, viewsets
from rest_framework.authentication import SessionAuthentication
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.status import HTTP_400_BAD_REQUEST, HTTP_200_OK

from super_notifications.models import Notification, NotificationType
from super_notifications.app_settings import NotificationSerializer


class NotificationsViewSet(mixins.ListModelMixin, viewsets.GenericViewSet):
    """
    This viewset returns the list of documents from an agency, and do CRUD operations on a document.
    """

    queryset = Notification.objects.all()
    # TODO : useful ? load different templates in serializer or choose different serializers
    # depending on the nf_type
    serializer_class = NotificationSerializer
    authentication_classes = [SessionAuthentication]
    lookup_field = 'pk'

    def get_queryset(self):
        queryset = self.queryset.unread().filter(recipient=self.request.user)
        return queryset

    def filter_queryset(self, queryset):
        if 'flag' in self.request.query_params:
            flag = self.request.query_params.get('flag')
            last_notification = int(flag) if flag.isdigit() else None

            if last_notification:
                new_queryset = queryset.filter(id__gt=last_notification).active().prefetch()
                return new_queryset
        return queryset

    @action(methods=['post'], detail=False, authentication_classes=[SessionAuthentication])
    def mark(self, request):
        notification_id = request.data.get('id', None)
        action = request.data.get('action', None)
        success = True

        if notification_id:
            try:
                notification = Notification.objects.get(pk=notification_id,
                                                        recipient=request.user)
                notification_type = NotificationType.objects.get(label=notification.nf_type, manual=True)

                if action == 'read':
                    notification.mark_as_read()
                    msg = "Marked as read"
                elif action == 'unread':
                    notification.mark_as_unread()
                    msg = "Marked as unread"
                else:
                    success = False
                    msg = "Invalid mark action."
            except Notification.DoesNotExist:
                success = False
                msg = "Notification does not exists."
            except NotificationType.DoesNotExist:
                success = False
                msg = "Notification type not readable manually"
        else:
            success = False
            msg = "Invalid Notification ID"
        ctx = {'message': msg, 'action': action}
        if not success:
            return Response(ctx, status=HTTP_400_BAD_REQUEST)
        else:
            return Response(ctx, status=HTTP_200_OK)

    # @action(methods=['get'], detail=False, authentication_classes=[SessionAuthentication])
    # def live(self, request):
    #     """
    #     Handles live updating of notifications, follows ajax-polling approach.
    #
    #     Read more: http://stackoverflow.com/a/12855533/4726598
    #
    #     Required URL parameters: ``flag``.
    #
    #     Explanation:
    #
    #         - The ``flag`` parameter carries the last notification ID \
    #         received by the user's browser.
    #
    #         - This ``flag`` is most likely to be generated by using \
    #         a simple JS/JQuery DOM. Just grab the first element of \
    #         the notification list.
    #
    #             - The element will have a ``data-id`` attribute set to the \
    #             corresponding notification.
    #             - We'll use it's value as the flag parameter.
    #
    #         - The view treats the ``last notification flag`` as a model \
    #         ```filter()`` and fetches all notifications greater than \
    #         the flag for the user.
    #
    #         - Then the a JSON data is prepared with all necessary \
    #         details such as, ``verb``, ``actor``, ``target`` and their \
    #         URL etc. The foreignkey are serialized as their \
    #         default ``__str__`` value.
    #
    #             - Everything will be HTML escaped by django's ``escape()``.
    #
    #         - Since these notification sent will only serve temporarily \
    #         on the notification box and will be generated fresh \
    #         using a whole template, to avoid client-side notification \
    #         generation using the JSON data, the JSON data will also \
    #         contain a rendered HTML string so that you can easily \
    #         do a JQuery ``$yourNotificationBox.prepend()`` on the \
    #         rendered html string of the notification.
    #
    #         - The template used is expected to be different than the \
    #         template used in full page notification as the css \
    #         and some other elements are highly likely to be \
    #         different than the full page notification list. \
    #
    #         - The template used will be the ``notification type`` of the \
    #         notification suffixed ``_box.html``. So, if your \
    #         notification type is ``comment_reply``, the template \
    #         will be ``comment_reply_box.html``.
    #
    #             - This template will be stored in ``notifications/includes/`` \
    #             of  your template directory.
    #
    #             - That makes: ``notifications/includes/comment_reply_box.html``
    #
    #         - The rest is self-explanatory.
    #
    #     :param request: HTTP request context.
    #
    #     :return: Notification updates (if any) in JSON format.
    #     """
    #     flag = request.GET.get('flag', None)
    #     last_notification = int(flag) if flag.isdigit() else None
    #
    #     if last_notification:
    #
    #         new_notifications = request.user.notifications.filter(
    #             id__gt=last_notification).active().prefetch()
    #
    #         msg = "Notifications successfully retrieved." if new_notifications else "No new notifications."
    #         notification_list = []
    #         for nf in new_notifications:
    #             # TODO: use Serializer -> NotificationSerializer instead of as_json
    #             notification = nf.as_json()
    #             notification_list.append(notification)
    #
    #         ctx = {
    #             "retrieved": len(new_notifications),
    #             "unread_count": request.user.notifications.unread().count(),
    #             "notifications": notification_list,
    #             "success": True,
    #             "msg": msg,
    #         }
    #
    #         return JsonResponse(ctx)
    #
    #     else:
    #         msg = "Notification flag not sent."
    #
    #     ctx = {"success": False, "msg": msg}
    #     return JsonResponse(ctx)